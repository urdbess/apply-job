





# 自我介绍

---

我叫谭皓禹，来自广东佛山，本科就读于华南理工大学数学学院信息与计算科学专业，然后保研到本校计算机学院，目前研三，研究方向是机器人室内导航技术，主要解决机器人在复杂环境中引发的导航出错现象。

研究生期间，

我参加了昇腾AI创新大赛，获得了广州赛区铜奖；

作为队长参加了研电赛，并获得全国总决赛二等奖和安谋专项企业奖一等奖；

也参与了华为鲲鹏众智项目，主要任务为实现滤波器函数库的生成函数，精度满足交付要求；

也有幸获得了腾讯企业一等奖学金。

暑假期间在小米实习，主要负责穿戴式设备系统层中表盘相关功能的开发，最主要的收获是熟悉了git团队开发流程，提高快速理解大型项目的业务逻辑并投入开发的能力，debug的能力，能更加注重程序的健壮性与可扩展性。

我认为自己有一定的信息检索能力，遇到的技术问题基本能通过国内外论坛解决；

并且具有良好的学习能力，可以在短时间内学习项目需要的技术并实践；



# 实习

---

在小米负责的其中一个项目是表盘的条件控制功能。

表现为对用户交互、数据变化的响应，比如点击屏幕、抬腕亮屏或数据源的值满足预设条件后，控制表盘的部件槽显示对应小部件，或者触发小部件动画。

目的：增加表盘的表现形式，比如制作日出日落主题表盘，表盘中有展示日出日落的弧形进度条，白天的进度条符号是太阳，夜晚是月亮。

## 难点

1. 读懂表盘从加载到渲染的整体业务流程，包括表盘资源的解析、渲染，数据源的订阅管理等逻辑。
2. 与产品协商功能需求，确保条件控制逻辑能够满足未来表盘可能需要的表现形式，以及功能的扩展性（提议升级固件协议，将条件抽象成表盘资源，而非在部件槽或小部件中分别实现，方便未来将条件控制扩展到其他资源上）。
2. 联调时经常出现前端制作的表盘无法正常显示，通过跟踪资源地址和二进制文件来排查，多次发现是前端提供的表盘资源文件不符合协议的问题，这种问题解决起来耗费时间，所以用c++写了个测试工具，可视化表盘按协议读取二进制文件的结果，并提示可能出错的结构体成员，后用于所有表盘资源的检测。

## 踩过的坑

### 背景

一个表盘的图片、条件、小部件等资源由各自结构体定义并存放在二进制文件中，这个二进制文件的生成是由前端按协议生成的。表盘渲染之前需要加载表盘二进制文件；

### 现象

加载过程中结构体按照协议读取二进制文件时，内容不符合预期。

### 问题

1. 对零长度数组的使用错误：零长度数组主要是为了实现变长结构体。其中一个结构体末尾有两个零长度数组，想当然地使用数组名去访问第二个数组，然而，由于第一个零长度数组占用空间的不确定性，编译器并不知道第二个数组的起始地址，因此想要访问第二个零长度数组只能通过手动偏移指针来实现。
2. 内存对齐问题：打开二进制文件对照地址检查，发现从某些结构体成员开始产生整体偏移，分析发现本地编译器默认四字节对齐优化，一些成员因内存对齐产生了偏移。解决办法一个是使用\_\_attribute__ ((packed))，取消结构体编译时的内存对齐优化，也就是一字节对齐。虽然会有读取性能损耗，但是避免了跨平台编译时不同平台的不同内存对齐方式导致的错误，其次考虑到二进制文件加载不频繁，损耗可忽略。对于这个读取性能的损耗，也可以通过添加一些保留成员进行结构体的手动对齐来规避一部分。

## 实现的大致流程

1.  渲染部件槽或小部件时注册其中的条件和满足条件时的回调函数，该回调函数负责切换小部件或播放动画；
2.  在注册条件时订阅所需的数据源或事件和对应的回调函数，该回调函数负责判断条件是否为真。

于是订阅的数据源或事件发生变化时，触发其对应的回调函数进行条件判断，条件判断为真时触发条件回调函数，最终实现小部件的切换或播放动画。

## 调试方法

- 代码静态分析：coverity
  - 内存泄漏、常量溢出、缓冲区溢出、使用未初始化变量、空指针引用
  - 原理：考虑代码中条件语句、循环以及分支等结构可能导致的不同执行路径，在每个可能的执行路径上进行数据流分析（跟踪变量的使用赋值、生命周期等）或控制流分析。
- 动态内存检测：addressSanitizer（ASAN）
  - 原理：
    - 在编译时将额外的代码插入到目标程序中，对内存的分配释放/读写操作进行检测和记录；
    - 运行时会接管malloc和free函数。malloc执行完后，已分配或释放的内存的会被标记，且暂时不会分配出去。运行时，ASan会监测内存访问，一旦发现内存访问错误，比如越界访问、释放后再次访问等，会立即输出错误信息并中断程序执行。
- 在线调试：gdb（虚拟机上用）
  - 监视或改变运行时内部状态
  - 打断点，根据调用栈来读懂代码运行逻辑
- 离线调试：core dump（虚拟机上用）
  - core文件：程序异常终止时，操作系统将程序的内存映像转储到core文件，包括调用栈，堆区，全局变量等
  - 使用：用gdb加载程序和core文件，backtrace还原崩溃时的调用栈
- 离线调试：backtrace（真机上用）
  - vela引入实时backtrace的支持
  - 作用：程序出错时打印出函数的调用堆栈，列出当前函数调用关系
  - 原理：用栈指针遍历栈内存，查找函数调用历史

# WEBSERVER

---

## 介绍

这个项⽬是我在学习计算机⽹络和网络编程过程中开发的轻量级Web服务器，实现用户的登录注册以及请求图片、视频等资源；服务器的⽹络模型实现了reactor和同步io模拟proactor加线程池的模式，IO处理使⽤了⾮阻塞IO和IO多路复⽤技术，具备并发处理客户端的http请求的能力；

项⽬中的⼯作可以分为两部分，⼀部分是服务器⽹络框架等⼀些基本系统的搭建，另⼀部分是为了提⾼服务器性能所做的⼀些优化，⽐如实现异步日志io，使用数据库连接池，定时器处理非活动连接机制。最后使用webbench对服务器进行压⼒测试，对监听socket和连接socket分别使用ET和LT模式测试，都可以实现上万的并发连接。

## 为什么做

项目是在学习计网的过程中逐步搭建的，这个项⽬综合性⽐较强，从中既能学习Linux环境下的⼀些系统调⽤，也能熟悉⽹络编程和⼀些⽹络框架，其中也根据⾃⼰的理解加⼊了⼀些性能调优的⼿段。

## 优化

1. 使用数据库连接池，减少系统频繁创建断开数据库连接的开销，并且用RAII机制管理数据库连接；

2. 实现异步日志io，防止io阻塞导致服务器并发能力降低，webbench测试在5000连接10s的情况下，异步日志QPS相比同步日志提高了10%；

3. 使用定时器关闭超时的非活动连接，防止连接长时间不交换数据，占用服务器端的文件描述符，浪费系统资源；

4. 一个针对定时器的优化：alarm函数中传入的时间参数由静态改为动态，减少了不必要的信号触发浪费：如果以静态的时间参数触发SIGALRM信号，调用定时器处理函数会造成触发浪费，比如当前静态时间参数是5ms，即每隔5ms触发一次SIGALRM，如果当前即将超时的连接距离现在还有20ms，那么在这期间，SIGALRM信号触发了4次，定时器处理函数执行了4次，可是前三次都是没有意义的；因此采用动态的时间参数，每次调用定时器处理函数后，将时间参数设置为最近超时时间与当前时间的时间差（因为定时器使用升序链表维护，所以表头的超时时间就是最近超时时间），这样就会减少触发浪费的现象，也减少了用户态和内核态之间的切换，因为一次信号处理需要用户态->内核态->用户态->内核态->用户态。

   

## 坑

客户端请求视频时，视频播放不完整或出错；

因为请求小文件没问题，大文件出问题，就把问题锁定在writev（）的使用：

我原本在while循环中只调用了writev，对返回值做异常情况处理，当请求小文件时，writev能够一次写完缓冲区的文件；当请求大文件时，受到文件描述符写缓冲区大小的限制，需要多次调用writev，通过打印日志查看每次发送的资源地址查到，每次调用writev发送的资源都和第一次发送的资源一模一样，于是就定位到问题出在iovec结构体在每次传输后并不会自动偏移指针和传输长度，导致了每次调用writev都按原来的指针和长度发送数据；

修正方法：每次调用writev后都更新iovec中下次传输的文件起始位置和长度。

## 其他知识点

### 说明服务器使用的并发模型？reactor、proactor、主从reactor模型的区别？

服务器实现了reactor模型、同步io模拟proactor模型+线程池的模型；

**区别：**

- 两者都是基于事件分发的网络编程模式，

- Reactor是非阻塞同步网络模式，感知的是就绪可读写的事件；在每次感知到有事件发生，比如读就绪事件，需要应用进程主动将socket缓存中的数据读到进程内存后才能进行下一步的业务处理，这个过程是同步的；

- Proactor是异步网络模式，感知的是已完成的读写事件；在发起异步读写请求时，读写过程由内核执行，线程可执行其他操作，读写完成后内核直接通知应用进程处理数据；

- Proactor不需要等待IO过程，效率更高。

**常见的reactor实现方案有：**

1. 单reactor单线程：不需要考虑线程间的数据同步问题，实现简单，但无法充分利用多核CPU；

2. 单reactor多线程：通过多线程充分利用CPU，但只有一个reactor承担所有事件的监听和响应，面对瞬间高并发场景容易成为性能瓶颈；

3. 多reactor多线程（主从reactor）：主reactor只负责建立连接和分配，从reactor负责监听事件，线程池中的工作线程负责读写、业务处理。

### Proactor这么好为什么不用？

Linux 下的异步 I/O 不完善：

1. aio 异步操作仅支持基于本地文件，不支持网络编程中的 socket；

2. aio 系列函数不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步。

# 面向独居老人的智能居家监护系统

---

## 项目背景

老龄化程度、市面上产品不足、独居老人风险更高

## 功能

我们的系统主要由云端服务器、姿态检测模块、语音识别模块、机器人联动服务模块和微信小程序组成。

云端服务器负责整个系统的通信，姿态检测模块和语音识别模块检测老人是否发生异常状态。

服务机器人的主要功能为响应老人的语音需求，比如老人喊一声“喝水”，机器人就能带着水来到老人身边；以及在老人出现异常状况时自动寻找并到达老人身边，送来急救药物和拍摄现场照片。

微信小程序让家人可以远程监护老人的状态。

## 主要工作

1. 构思项目的功能需求，设计系统的总体架构，探索各个功能模块的技术可行性（包括在R329上部署离线语音库、DK610能否装上ubuntu作为控制机器人的上位机）；
2. 实现系统各个设备之间的通信；
3. 机器人的所有功能开发，包括房间分区巡逻、狭窄空间导航的优化、全局路径优化、多传感器融合的自动寻人功能。

# 最大的挑战

---

待



